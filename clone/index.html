<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="教你手撸深拷贝与浅拷贝"><meta name="keywords" content="深拷贝与浅拷贝,面试"><meta name="author" content="ahuiyoのblog"><meta name="copyright" content="ahuiyoのblog"><title>教你手撸深拷贝与浅拷贝 | Ahuiyo の Blog</title><link rel="shortcut icon" href="http://m.qpic.cn/psb?/V11M0n3k1MLvUr/Ghek*U0iFv5um.lq0hQ6LTr0tgw*ue0S2U.xg.MF*Bk!/b/dDUBAAAAAAAA&bo=kAGQAQAAAAADFzI!&rf=viewer_4"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?1a81b1b2645f98e73ba1edbd21b65a06";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"2EK5LLOYMB","apiKey":"77327bcf9825fe3a244e5a16090bcabc","indexName":"blog","hits":{"per_page":10},"languages":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}.","hits_stats":"${hits} results found in ${time} ms"}},
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#深拷贝和浅拷贝"><span class="toc-text">深拷贝和浅拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#初识"><span class="toc-text">初识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码实现浅拷贝"><span class="toc-text">代码实现浅拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-循环遍历对象可枚举值"><span class="toc-text">1. 循环遍历对象可枚举值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Object-assign"><span class="toc-text">2. Object.assign()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Array-prototype-concat"><span class="toc-text">3. Array. prototype. concat ()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Array-prototype-slice"><span class="toc-text">4. Array. prototype. slice ()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-展开运算符…-obj"><span class="toc-text">5.展开运算符… obj</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码实现深拷贝"><span class="toc-text">代码实现深拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-手写深拷贝"><span class="toc-text">1. 手写深拷贝</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-JSON-parse-JSON-stringify"><span class="toc-text">2. JSON. parse (JSON. stringify())</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-函数库Lodash"><span class="toc-text">3.函数库Lodash</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-框架jQuery中extend-方法"><span class="toc-text">4.框架jQuery中extend() 方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="http://m.qpic.cn/psb?/V11M0n3k1MLvUr/LMJ1TpXuAan5gZG6ZL63WvYF4Tnvoh8V3jPuOMSX9vY!/b/dMUAAAAAAAAA&amp;bo=mALBAgAAAAARF3k!&amp;rf=viewer_4"></div><div class="author-info__name text-center">ahuiyoのblog</div><div class="author-info__description text-center">前端菜鸟一个，奋斗中😁</div><div class="follow-button"><a href="http://wpa.qq.com/msgrd?v=3&amp;uin=768837811&amp;site=qq&amp;menu=yes">使劲戳一下</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">24</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">32</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">16</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">友情链接</div><a class="author-info-links__name text-center" href="https://github.com/ahuiyo">github</a><a class="author-info-links__name text-center" href="https://blog.csdn.net/qq_41761591">CSDN</a><a class="author-info-links__name text-center" href="https://xiao.algerfan.cn">JaneChelle</a><a class="author-info-links__name text-center" href="http://by.wlgzs.club/">BY</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(http://m.qpic.cn/psb?/V11M0n3k1MLvUr/eFA3vQcs2rJKLFjNvNWaCFkeShvWC2HnH2kjT4Auqqs!/b/dLYAAAAAAAAA&amp;bo=sASjAgAAAAARByU!&amp;rf=viewer_4)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Ahuiyo の Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/about">关于我</a><a class="site-page" href="/archives">博客</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">教你手撸深拷贝与浅拷贝</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-12-03</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/面经/">面经</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/面经/知识点/">知识点</a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">3.1k</span><span class="post-meta__separator">|</span><span>Reading time: 12 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h2><h3 id="初识"><a href="#初识" class="headerlink" title="初识"></a>初识</h3><p>&emsp;&emsp;js中数据分为基本数据类型如<code>null</code>、<code>string</code>、<code>undefined</code>、<code>number</code>、<code>boolean</code>、<code>symbol</code>，以及引用数据类型如<code>对象</code>和<code>数组</code>。</p>
<p>&emsp;&emsp;而在js中存储方式也是分栈和堆，基础数据类型是栈存储，引用数据类型一般是堆存储。</p>
<p>&emsp;&emsp;深拷贝和浅拷贝是对于复杂类型而言的。</p>
<a id="more"></a>
<p>&emsp;&emsp;下面先通过一个简单的例子进行说明其区别。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接赋值</span></span><br><span class="line"><span class="keyword">const</span> initData = [ <span class="number">1</span> , &#123; <span class="attr">obj</span>: <span class="string">'123'</span> &#125; ];</span><br><span class="line"><span class="keyword">const</span> finalData = initData;</span><br><span class="line">finalData[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">finalData[<span class="number">1</span>].obj = <span class="string">'456'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(initData);  <span class="comment">// [ 2, &#123; obj: '456' &#125; ]</span></span><br><span class="line"><span class="built_in">console</span>.log(finalData); <span class="comment">// [ 2, &#123; obj: '456' &#125; ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本数据类型</span></span><br><span class="line"><span class="keyword">let</span> str1 = <span class="string">'123'</span>;</span><br><span class="line">str2 = str1;</span><br><span class="line">str2 = <span class="string">'456'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str1); <span class="comment">// '123'</span></span><br><span class="line"><span class="built_in">console</span>.log(str2); <span class="comment">// '456'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// // 引用数据类型</span></span><br><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr2 = arr1;</span><br><span class="line">arr2.push(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr1); <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2); <span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;我们在例子中可以看到，在直接赋值的情况下，修改finalData也会改变原来的initData，而基本数据类型的拷贝，修改str2不会影响原来的str1，而引用数据类型的拷贝，修改arr2会影响原来的arr1。</p>
<p>&emsp;&emsp;那么这样就诞生了一个问题，在平时咱们怎么能进行限次数的拷贝，从而能保证修改拷贝后的数据一直不会影响原来的数据呢？这就是深拷贝的基本概念了。针对以上问题，咱们可以把想法思维化，先写个小demo，先把各个需要的功能简单罗列一下。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @name 赋值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> dataOne = &#123;</span><br><span class="line">    title: <span class="string">'study'</span>,</span><br><span class="line">    number: [<span class="string">'html'</span>, <span class="string">'css'</span>, <span class="string">'javascript'</span>],</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> dataTwo = dataOne;</span><br><span class="line">  dataTwo.title = <span class="string">'play'</span>;</span><br><span class="line">  dataTwo.number = [<span class="string">'null'</span>];</span><br><span class="line">  <span class="built_in">console</span>.log(dataOne);</span><br><span class="line">  <span class="comment">// dataOne: &#123; title: 'play', number: ['null'] &#125;</span></span><br><span class="line">  <span class="built_in">console</span>.log(dataTwo);</span><br><span class="line">  <span class="comment">// dataTwo: &#123; title: 'play', number: ['null'] &#125;</span></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @name 浅拷贝</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> dataThree = &#123;</span><br><span class="line">    title: <span class="string">'study'</span>,</span><br><span class="line">    number: [<span class="string">'html'</span>, <span class="string">'css'</span>, <span class="string">'javascript'</span>],</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> dataFour = shallowClone(dataThree); <span class="comment">// shallowClone 待实现</span></span><br><span class="line">  dataFour.title = <span class="string">'play'</span>;</span><br><span class="line">  dataFour.number = [<span class="string">'null'</span>];</span><br><span class="line">  <span class="built_in">console</span>.log(dataThree);</span><br><span class="line">  <span class="comment">// dataThree: &#123; title: 'study', number: ['null'] &#125;</span></span><br><span class="line">  <span class="built_in">console</span>.log(dataFour);</span><br><span class="line">  <span class="comment">// dataFour: &#123; title: 'play', number: ['null'] &#125;</span></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @name 深拷贝</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> dataFive = &#123;</span><br><span class="line">    title: <span class="string">'study'</span>,</span><br><span class="line">    number: [<span class="string">'html'</span>, <span class="string">'css'</span>, <span class="string">'javascript'</span>],</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> dataSix = deepClone(dataFive); <span class="comment">// deepClone 待实现</span></span><br><span class="line">  dataSix.title = <span class="string">'play'</span>;</span><br><span class="line">  dataSix.number = [<span class="string">'null'</span>];</span><br><span class="line">  <span class="built_in">console</span>.log(dataFive);</span><br><span class="line">  <span class="comment">// dataFive: &#123; title: 'study', number: ['html', 'css', 'javascript'] &#125;</span></span><br><span class="line">  <span class="built_in">console</span>.log(dataSix);</span><br><span class="line">  <span class="comment">// dataSix: &#123; title: 'play', number: ['null'] &#125;</span></span><br></pre></td></tr></table></figure>

<p>经过上面的实例，就这样把拷贝分成了三种情况，大致意思就是这样：</p>
<ul>
<li><p>赋值：引用地址的拷贝。修改赋值后的数据，不管是基本数据类型还是引用数据类型，都会影响到原数据。</p>
</li>
<li><p>浅拷贝：一层拷贝。在浅拷贝中，修改基本数据类型不会影响原有数据的基本数据类型，修改引用数据类型会影响原有的数据类型。</p>
</li>
<li><p>深拷贝：无限层级拷贝。在深拷贝中，修改基本数据类型和引用数据类型都不会影响原有的数据类型。</p>
</li>
</ul>
<p>&emsp;&emsp;深拷贝与桥拷贝可能在日常开发中都碰不到，但是确是面试常问的问题，虽然碰不到，但是怎么手写一个浅拷贝或深拷贝，确是能用到很多知识，还是值得学习的。</p>
<h3 id="代码实现浅拷贝"><a href="#代码实现浅拷贝" class="headerlink" title="代码实现浅拷贝"></a>代码实现浅拷贝</h3><h4 id="1-循环遍历对象可枚举值"><a href="#1-循环遍历对象可枚举值" class="headerlink" title="1. 循环遍历对象可枚举值"></a>1. 循环遍历对象可枚举值</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 手写浅拷贝</span></span><br><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, [<span class="string">'html'</span>, <span class="string">'css'</span>], <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> shallowClone = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> dst = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">in</span> arr) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(prop)</span><br><span class="line">    <span class="keyword">if</span> (arr.hasOwnProperty(prop)) &#123;</span><br><span class="line">        dst[prop] = arr[prop];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr2 = shallowClone(arr1);</span><br><span class="line">arr2[<span class="number">2</span>].push(<span class="string">'Javascript'</span>);</span><br><span class="line">arr2[<span class="number">3</span>] = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr1);</span><br><span class="line"><span class="comment">// [ 1,2,['html','css','Javascript'], 4 ]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2);</span><br><span class="line"><span class="comment">// [1,2,['html','css','Javascript'], 5 ]</span></span><br></pre></td></tr></table></figure>

<p>手写思路：</p>
<ul>
<li><code>for... in</code> : 遍历Object对象arr1，将骑可枚举值列举出来。</li>
<li><code>hasOwnProperty ()</code> : 检查该枚举值是否属于该对象arr1, 如果是继承过来的就去掉，如果是自身的则进行拷贝。</li>
</ul>
<h4 id="2-Object-assign"><a href="#2-Object-assign" class="headerlink" title="2. Object.assign()"></a>2. Object.assign()</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    name : <span class="string">"张三"</span>,</span><br><span class="line">    age : <span class="string">"16"</span>,</span><br><span class="line">    skill : &#123;</span><br><span class="line">        read : <span class="string">"html"</span>,</span><br><span class="line">        write : <span class="string">"css"</span></span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    like : [<span class="string">'吃饭'</span>,<span class="string">'睡觉'</span>,<span class="string">'敲代码'</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newobj = <span class="built_in">Object</span>.assign(&#123;&#125;,obj)</span><br><span class="line"></span><br><span class="line">newobj.name = <span class="string">"李四"</span></span><br><span class="line">newobj.skill.read = <span class="string">"js"</span></span><br><span class="line">newobj.like = [<span class="string">"玩耍"</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj)  </span><br><span class="line"><span class="comment">// &#123; name: '张三',</span></span><br><span class="line"><span class="comment">//   age: '16',</span></span><br><span class="line"><span class="comment">//   skill: &#123; read: 'js', write: 'css' &#125;,</span></span><br><span class="line"><span class="comment">//   like: [ '吃饭', '睡觉', '敲代码' ] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(newobj)</span><br><span class="line"><span class="comment">// &#123; name: '李四',</span></span><br><span class="line"><span class="comment">//   age: '16',</span></span><br><span class="line"><span class="comment">//   skill: &#123; read: 'js', write: 'css' &#125;,</span></span><br><span class="line"><span class="comment">//   like: [ '玩耍' ] &#125;</span></span><br></pre></td></tr></table></figure>

<p><code>Object.assign()</code> 方法是ES6新增方法，可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。</p>
<p>通过代码可以看到的是，<code>Object.assign()</code> 对于第一层的数据来说，是深拷贝，对于第二层及以上的数据来说，是浅拷贝。</p>
<h4 id="3-Array-prototype-concat"><a href="#3-Array-prototype-concat" class="headerlink" title="3. Array. prototype. concat ()"></a>3. Array. prototype. concat ()</h4><p><code>concat ()</code>是数组的一个内置方法，用户合并两个或者多个数组。这个方法不会改变现有数组，而是返回一个新数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,&#123; <span class="attr">name</span> : <span class="string">"张三"</span>, <span class="attr">age</span> : <span class="string">"16"</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newarr = arr.concat()</span><br><span class="line"></span><br><span class="line">newarr[<span class="number">0</span>] = <span class="number">3</span></span><br><span class="line">newarr[<span class="number">2</span>].name = <span class="string">"李四"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr)  <span class="comment">// [ 1, 2, &#123; name: '李四', age: '16' &#125; ]</span></span><br><span class="line"><span class="built_in">console</span>.log(newarr) <span class="comment">// [ 3, 2, &#123; name: '李四', age: '16' &#125; ]</span></span><br></pre></td></tr></table></figure>

<h4 id="4-Array-prototype-slice"><a href="#4-Array-prototype-slice" class="headerlink" title="4. Array. prototype. slice ()"></a>4. Array. prototype. slice ()</h4><p><code>slice()</code>也是数组的一个内置方法，该方法会返回一个新的对象。<code>slice()</code>不会改变原数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,&#123; <span class="attr">name</span> : <span class="string">"张三"</span>, <span class="attr">age</span> : <span class="string">"16"</span>&#125;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newarr = arr.slice()</span><br><span class="line"></span><br><span class="line">newarr[<span class="number">0</span>] = <span class="number">3</span></span><br><span class="line">newarr[<span class="number">2</span>].name = <span class="string">"李四"</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(arr)  <span class="comment">// [ 1, 2, &#123; name: '李四', age: '16' &#125; ]</span></span><br><span class="line"><span class="built_in">console</span>.log(newarr) <span class="comment">// [ 3, 2, &#123; name: '李四', age: '16' &#125; ]</span></span><br></pre></td></tr></table></figure>

<h4 id="5-展开运算符…-obj"><a href="#5-展开运算符…-obj" class="headerlink" title="5.展开运算符… obj"></a>5.展开运算符… obj</h4><p>展开运算符是ES6中新提出来的一种运算符。在拷贝数组、对象以及拼接数组等方面都可以使用。这边我们也可以尝试下使用<code>const obj2 = {..obj1}</code> 的形式进行浅拷贝。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,&#123; <span class="attr">name</span> : <span class="string">"张三"</span>, <span class="attr">age</span> : <span class="string">"16"</span>&#125;]</span><br><span class="line"><span class="keyword">const</span> newarr = [...arr]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [ 1, 2, &#123; name: '张三', age: '16' &#125; ]</span></span><br><span class="line"><span class="built_in">console</span>.log(newarr) <span class="comment">// [ 1, 2, &#123; name: '张三', age: '16' &#125; ]</span></span><br><span class="line"></span><br><span class="line">newarr[<span class="number">0</span>] = <span class="number">3</span></span><br><span class="line">newarr[<span class="number">2</span>].name = <span class="string">"李四"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [ 1, 2, &#123; name: '李四', age: '16' &#125; ]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(newarr) <span class="comment">// [ 3, 2, &#123; name: '李四', age: '16' &#125; ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于对象进行浅拷贝</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    name : <span class="string">"张三"</span>,</span><br><span class="line">    age : <span class="string">"16"</span>,</span><br><span class="line">    like : [<span class="string">'吃饭'</span>,<span class="string">'睡觉'</span>,<span class="string">'敲代码'</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> newobj = &#123;...obj&#125;</span><br><span class="line"></span><br><span class="line">newobj.like.push(<span class="string">'打豆豆'</span>)</span><br><span class="line">newobj.name = <span class="string">"李四"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj) </span><br><span class="line"><span class="comment">// &#123; name: '张三', age: '16', like: [ '吃饭', '睡觉', '敲代码', '打豆豆' ] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(newobj) </span><br><span class="line"><span class="comment">// &#123; name: '李四', age: '16', like: [ '吃饭', '睡觉', '敲代码', '打豆豆' ] &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="代码实现深拷贝"><a href="#代码实现深拷贝" class="headerlink" title="代码实现深拷贝"></a>代码实现深拷贝</h3><p>&emsp;&emsp;经过对浅拷贝的简单了解，咱们就到了如何实现深拷贝的问题上，常见的循环遍历，只是遍历了一层数据，明显解决不了这个问题，不过咱们可以看出，深拷贝的问题不就在于怎么解决无限层级拷贝问题吗，这种数据类型似乎在哪见过，对没错，可以用递归解决！</p>
<p>&emsp;&emsp;咱们先对浅拷贝代码进行改造，用了递归之后就实现了一个深拷贝。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> deepClone = <span class="function">(<span class="params">source</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> target = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> i <span class="keyword">in</span> source) &#123;</span><br><span class="line">      <span class="keyword">if</span> (source.hasOwnProperty(i)</span><br><span class="line">        &amp;&amp; target[i] === <span class="string">'object'</span>) &#123;</span><br><span class="line">        target[i] = deepClone(source[i]); <span class="comment">// 注意这里</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        target[i] = source[i];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<p>但是这份代码还有一些细节需要修改，如：</p>
<ul>
<li><p>没有对参数进行校验，如果传入进来的不是对象或者数组，我们直接返回即可。</p>
</li>
<li><p>通过 typeof 判断是否对象的逻辑不够严谨。 typeof  null</p>
</li>
</ul>
<p>对此可进行改进，实现一份完整的深拷贝代码。</p>
<h4 id="1-手写深拷贝"><a href="#1-手写深拷贝" class="headerlink" title="1. 手写深拷贝"></a>1. 手写深拷贝</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义检测数据类型的功能函数</span></span><br><span class="line"><span class="keyword">const</span> checkedType = <span class="function">(<span class="params">target</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// console.log(Object.prototype.toString.call(target))</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(target));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(target).slice(<span class="number">8</span>, <span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 实现深度克隆对象或者数组</span></span><br><span class="line">  <span class="keyword">const</span> deepClone = <span class="function">(<span class="params">target</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 判断拷贝的数据类型</span></span><br><span class="line">    <span class="comment">// 初始化变量 result 成为最终数据</span></span><br><span class="line">    <span class="keyword">let</span> result, targetType = checkedType(target);</span><br><span class="line">    <span class="keyword">if</span> (targetType === <span class="string">'Object'</span>) &#123;</span><br><span class="line">      result = &#123;&#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (targetType === <span class="string">'Array'</span>) &#123;</span><br><span class="line">      result = [];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 遍历目标数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> target) &#123;</span><br><span class="line">      <span class="comment">// 获取遍历数据结构的每一项值</span></span><br><span class="line">      <span class="keyword">let</span> value = target[i];</span><br><span class="line">      <span class="comment">// 判断目标结构里的每一项值是否存在对象或者数组</span></span><br><span class="line">      <span class="keyword">if</span> (checkedType(value) === <span class="string">'Object'</span> || checkedType(value) === <span class="string">'Array'</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果对象或者数组中还嵌套了对象或者数组，那么继续遍历</span></span><br><span class="line">        result[i] = deepClone(value);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result[i] = value;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 返回最终值</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> obj1 = [</span><br><span class="line">    <span class="number">1</span>,</span><br><span class="line">    <span class="string">'Hello!'</span>,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">'张'</span> &#125;,</span><br><span class="line">    [</span><br><span class="line">      &#123;</span><br><span class="line">        name: <span class="string">'李'</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">  ]</span><br><span class="line">  <span class="keyword">const</span> obj2 = deepClone(obj1);</span><br><span class="line">  obj2[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">  obj2[<span class="number">1</span>] = <span class="string">'Hi!'</span>;</span><br><span class="line">  obj2[<span class="number">2</span>].name = <span class="string">'小张'</span>;</span><br><span class="line">  obj2[<span class="number">3</span>][<span class="number">0</span>].name = <span class="string">'小李'</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">console</span>.log(obj1);</span><br><span class="line">  <span class="comment">//  [ 1, 'Hello!', &#123; name: '张' &#125;, [ &#123; name: '李' &#125; ] ]</span></span><br><span class="line">  <span class="built_in">console</span>.log(obj2);</span><br><span class="line">  <span class="comment">//  [ 2, 'Hi!', &#123; name: '小张' &#125;, [ &#123; name: '小李' &#125; ] ]</span></span><br></pre></td></tr></table></figure>

<p>经过深拷贝后，我们可以看到，再修改引用数据类型里的值时，原对象毫不收到影响，说明这份代码还是挺成功的。下面是代码的实现思路：</p>
<ul>
<li><p><code>Object.prototype.toString.call()</code>：稳健地判断 <code>JavaScript</code> 数据类型方式，可以符合预期的判断基本数据类型 <code>String</code>、<code>Undefined</code> 等，也可以判断 <code>Array</code>、<code>Object</code> 这些引用数据类型。</p>
</li>
<li><p>然后，我们通过方法 <code>targetType()</code> 中的 <code>Object.prototype.toString.call()</code>，判断传入的数据类型属于那种，从而改变 <code>result</code> 的值为 {}、[] 或者直接返回传入的值<code>（return target）</code>。</p>
</li>
<li><p>最后，我们再通过 <code>for...in</code> 判断 <code>target</code> 的所有元素，如果属于 {} 或者 []，那么就递归再进行 <code>clone()</code> 操作；</p>
</li>
<li><p>如果是基本数据类型，则直接传递到数组中……从而在最后返回一个深拷贝的数据。</p>
</li>
</ul>
<p>但是如果经过严格的测试，这份代码也是行不通的，如果拷贝对象是个循环空对象，那么咱们将把自己绕进去，写了个死循环。而对广度和深度进行测试后，数据大的话，也是行不通的，十分容易爆栈。</p>
<p>这就是手写深拷贝待解决的两个大问题：</p>
<ul>
<li>死循环</li>
<li>爆栈</li>
</ul>
<p>解决方法，博主也是了解的比较少，能简单理解到：</p>
<ul>
<li>死循环的解决是用<code>哈希表</code>进行循环检测，我们设置一个数组或者哈希表存储已拷贝过的对象，当检测到当前对象已存在于哈希表中时，取出该值并返回即可。</li>
<li>爆栈的问题可用栈解决</li>
</ul>
<p>这里就不过多解释了，有兴趣的可去大佬文章深挖。</p>
<p><a href="https://segmentfault.com/a/1190000019462847" target="_blank" rel="noopener">面试题之如何实现一个深拷贝</a><br><a href="https://segmentfault.com/a/1190000016672263" target="_blank" rel="noopener">深拷贝的终极探索</a></p>
<h4 id="2-JSON-parse-JSON-stringify"><a href="#2-JSON-parse-JSON-stringify" class="headerlink" title="2. JSON. parse (JSON. stringify())"></a>2. JSON. parse (JSON. stringify())</h4><ul>
<li><code>JSON. stringify()</code>:将对象转成JSON 字符串。</li>
<li><code>JSON. parse()</code>:将字符串解析成对象。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr1 = [</span><br><span class="line">    <span class="number">1</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      username: <span class="string">'zhangsan'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  ];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> arr2 = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(arr1));</span><br><span class="line">  arr2[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">  arr2[<span class="number">1</span>].username = <span class="string">'li'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(arr1);</span><br><span class="line">  <span class="comment">// [ 1, &#123; username: 'zhangsan' &#125; ]</span></span><br><span class="line">  <span class="built_in">console</span>.log(arr2);</span><br><span class="line">  <span class="comment">// [ 2, &#123; username: 'li' &#125; ]</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;通过<code>JSON. parse (JSON. stringify())</code>将<code>JavaScript</code> 对象转序列化(转换成<code>JSON</code>字符串)，再将其还原成JavaScript对象，一去一 来我们就产生了一个新的对象，而且对象会开辟新的栈，从而实现深拷贝。</p>
<p>&emsp;&emsp;此方法虽然简单，但是却有很多局限性。</p>
<ul>
<li>1、不能存放<code>函数</code>或者 <code>Undefined</code>，否则会丢失<code>函数</code>或者 <code>Undefined</code>；</li>
<li>2、不要存放时间对象，否则会变成字符串形式；</li>
<li>3、不能存放 <code>RegExp</code>、<code>Error</code> 对象，否则会变成空对象；</li>
<li>4、不能存放 <code>NaN</code>、<code>Infinity</code>、<code>-Infinity</code>，否则会变成 <code>null</code>；</li>
</ul>
<h4 id="3-函数库Lodash"><a href="#3-函数库Lodash" class="headerlink" title="3.函数库Lodash"></a>3.函数库Lodash</h4><p><code>Lodash</code>作为一个<code>JavaScript</code> 函数库/工具库，它里面有非常好用的封装好的功能，大家可以去试试,这里我们查看下它的<code>cloneDeep()</code> 方法,该方法会递归拷贝<code>value</code>。</p>
<p>首先需要<code>npm</code>先下载<code>lodash</code>包</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> lodash = <span class="built_in">require</span>(<span class="string">'lodash'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj1 = [</span><br><span class="line">  <span class="number">1</span>,</span><br><span class="line">  <span class="string">'Hello!'</span>,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'html'</span> &#125;,</span><br><span class="line">  [</span><br><span class="line">    &#123;</span><br><span class="line">      name: <span class="string">'css'</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">]</span><br><span class="line"><span class="keyword">const</span> obj2 = lodash.cloneDeep(obj1);</span><br><span class="line">obj2[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">obj2[<span class="number">1</span>] = <span class="string">'Hi!'</span>;</span><br><span class="line">obj2[<span class="number">2</span>].name = <span class="string">'lodash'</span>;</span><br><span class="line">obj2[<span class="number">3</span>][<span class="number">0</span>].name = <span class="string">'js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj1);</span><br><span class="line"><span class="comment">// [ 1, 'Hello!', &#123; name: 'html' &#125;, [ &#123; name: 'css' &#125; ] ]</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2);</span><br><span class="line"><span class="comment">// [ 2, 'Hi!', &#123; name: 'lodash' &#125;, [ &#123; name: 'js' &#125; ] ]</span></span><br></pre></td></tr></table></figure>

<h4 id="4-框架jQuery中extend-方法"><a href="#4-框架jQuery中extend-方法" class="headerlink" title="4.框架jQuery中extend() 方法"></a>4.框架jQuery中extend() 方法</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = [</span><br><span class="line">        <span class="number">1</span>,</span><br><span class="line">        <span class="string">'Hello!'</span>,</span><br><span class="line">        &#123; <span class="attr">name</span>: <span class="string">'html'</span> &#125;,</span><br><span class="line">        [</span><br><span class="line">          &#123;</span><br><span class="line">            name: <span class="string">'css'</span>,</span><br><span class="line">          &#125;</span><br><span class="line">        ],</span><br><span class="line">      ]</span><br><span class="line">      <span class="keyword">const</span> obj2 = &#123;&#125;;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * @name jQuery深拷贝</span></span><br><span class="line"><span class="comment">       * @description $.extend(deep, target, object1, object2...)</span></span><br><span class="line"><span class="comment">       * @param &#123;Boolean&#125; deep 可选 true 或者 false，默认是 false，所以一般如果需要填写，最好是 true。</span></span><br><span class="line"><span class="comment">       * @param &#123;Object&#125; target 需要存放的位置</span></span><br><span class="line"><span class="comment">       * @param &#123;Object&#125; object 可以有 n 个原数据</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      $.extend(<span class="literal">true</span>, obj2, obj1);</span><br><span class="line">      obj2[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">      obj2[<span class="number">1</span>] = <span class="string">'Hi!'</span>;</span><br><span class="line">      obj2[<span class="number">2</span>].name = <span class="string">'js'</span>;</span><br><span class="line">      obj2[<span class="number">3</span>][<span class="number">0</span>].name = <span class="string">'jq'</span>;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">console</span>.log(obj1);</span><br><span class="line">      <span class="built_in">console</span>.log(obj2);</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>&emsp;&emsp;之前浏览博客的时候，总是看到别人关于深拷贝与浅拷贝的文章，也知道面试这是常问的知识点，但是一直没怎么看。而在前不久，在小组轮到我讲课了，思来想去讲写什么，最后决定讲这个，经过一星期的学习，真的学习到了不少，碰到任何不懂的问题，自己立马去搜了搜，也连联想了许多相关的知识点，也算是把这一难点学会了，虽然平时可能用不用到，但用不用的到并不是关键，要的是学会知识😁，一个深拷贝却蕴含了那么多的知识点，谁能想的到，平时可能也不会怎么注意吧。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">ahuiyoのblog</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://ahuiyo.cn/clone/">http://ahuiyo.cn/clone/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/深拷贝与浅拷贝/">深拷贝与浅拷贝</a><a class="post-meta__tags" href="/tags/面试/">面试</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="http://m.qpic.cn/psb?/V11M0n3k1MLvUr/jotZT9jJu7t2EKLpzQivLHDU.KPUg9Z8dW0195VTM8s!/b/dLYAAAAAAAAA&amp;bo=iAF7AYgBewEDByI!&amp;rf=viewer_4"><div class="post-qr-code__desc">支付宝打赏</div></div><div class="post-qr-code-item"><img class="post-qr-code__img" src="http://m.qpic.cn/psb?/V11M0n3k1MLvUr/sesR4bZ2nUiil.PV5VVIEjj*enrKkLF9gISIg0j1ffI!/b/dDEBAAAAAAAA&amp;bo=RQI6AgAAAAARB08!&amp;rf=viewer_4"><div class="post-qr-code__desc">微信打赏</div></div></div><div class="social-share pull-right"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/createContext/"><i class="fa fa-chevron-left">  </i><span>解决react报错   TypeError:_WEBPACK_IMPORTED_MODULE_0_react___default.a.createContext is not a function</span></a></div><div class="next-post pull-right"><a href="/Essay191201/"><span>一周随笔（1201）</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="vcomment"></div><script src="https://cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = 'false' == true ? true : false;
var verify = 'false' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'LvKxkTKY8Kh4wAgvkaeIo9s5-gzGzoHsz',
  appKey:'C4redbOo8k1BrOKY7ordoz5r',
  placeholder:'快来留言吧，大佬务必留下邮箱哦，有回复时会邮件通知哒~~',
  avatar:'http://m.qpic.cn/psb?/V11M0n3k1MLvUr/LMJ1TpXuAan5gZG6ZL63WvYF4Tnvoh8V3jPuOMSX9vY!/b/dMUAAAAAAAAA&amp;bo=mALBAgAAAAARF3k!&amp;rf=viewer_4',
  guest_info:guest_info,
  pageSize:'10',
  lang: 'zh-cn'
})</script></div></div><footer class="footer-bg" style="background-image: url(http://m.qpic.cn/psb?/V11M0n3k1MLvUr/eFA3vQcs2rJKLFjNvNWaCFkeShvWC2HnH2kjT4Auqqs!/b/dLYAAAAAAAAA&amp;bo=sASjAgAAAAARByU!&amp;rf=viewer_4)"><div class="layout" id="footer"><div class="copyright">&copy;2019 By ahuiyoのblog</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://ahuiyo.cn">blog</a></div><div class="icp"><a><span></span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script src="/js/search/algolia.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>